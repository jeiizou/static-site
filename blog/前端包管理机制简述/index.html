<!doctype html>
<html lang="zh-Hans" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.1.0">
<title data-rh="true">前端包管理机制简述 | world</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://localhost:3000/blog/前端包管理机制简述"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="前端包管理机制简述 | world"><meta data-rh="true" name="description" content="从package.json文件说起"><meta data-rh="true" property="og:description" content="从package.json文件说起"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2022-11-27T12:45:29.000Z"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://localhost:3000/blog/前端包管理机制简述"><link data-rh="true" rel="alternate" href="https://localhost:3000/blog/前端包管理机制简述" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://localhost:3000/blog/前端包管理机制简述" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="world RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="world Atom Feed"><link rel="stylesheet" href="/assets/css/styles.5d8c6f17.css">
<link rel="preload" href="/assets/js/runtime~main.0fe2848a.js" as="script">
<link rel="preload" href="/assets/js/main.755b20c3.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a href="#" class="skipToContent_B8Ea">跳到主要内容</a></div><nav class="navbar navbar--fixed-top navbarHideable_cmch"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><b class="navbar__title text--truncate">Jeiiz&#x27;s World</b></a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/docs/intro">Wiki</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a><div class="toggle_Wbdk colorModeToggle_qKyZ"><button class="clean-btn toggleButton_ZMwS toggleButtonDisabled_bkOl" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_v5D6"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_ZxuA"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_aLgs"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_Bh6J"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_yPvC thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_G95M margin-bottom--md">Recent posts</div><ul class="sidebarItemList__3bY clean-list"><li class="sidebarItem_YlO7"><a class="sidebarItemLink_K83y" href="/blog/Deno, 以及相关的一切">Deno, 及其相关的一切</a></li><li class="sidebarItem_YlO7"><a class="sidebarItemLink_K83y" href="/blog/关于 vscode 的一些废话">关于 vscode 的一些废话</a></li><li class="sidebarItem_YlO7"><a aria-current="page" class="sidebarItemLink_K83y sidebarItemLinkActive_rG8h" href="/blog/前端包管理机制简述">前端包管理机制简述</a></li><li class="sidebarItem_YlO7"><a class="sidebarItemLink_K83y" href="/blog/前端项目结构演进">前端项目结构演进</a></li><li class="sidebarItem_YlO7"><a class="sidebarItemLink_K83y" href="/blog/小程序概览">小程序概览</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="title_N7oF" itemprop="headline">前端包管理机制简述</h1><div class="container_HhK3 margin-vert--md"><time datetime="2022-11-27T12:45:29.000Z" itemprop="datePublished">2022年11月27日</time> · <!-- -->阅读需 24 分钟</div></header><div id="post-content" class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithHideOnScrollNavbar_rm2F" id="从packagejson文件说起">从<code>package.json</code>文件说起<a class="hash-link" href="#从packagejson文件说起" title="标题的直接链接">​</a></h2><p><code>package.json</code>是前端领域中用来描述一个包信息的描述文件. 其中, 只有两个字段是必填的:</p><ul><li><code>name</code>: 模块名称, 可以用<code>validate-npm-package-name</code>来检测包名是否合法, 因为包名是唯一的, npm也提供<code>npm view packageName</code>来检测包名是否被占用.</li><li><code>version</code>: 模块版本, npm的模块版本遵循<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener noreferrer"><code>SemVer</code></a>规范, 即<code>主版本号.此版本号.修订号</code>. 可以使用<code>semver</code>包来进行比较版本, 提取版本信息等操作. </li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_rm2F" id="依赖管理">依赖管理<a class="hash-link" href="#依赖管理" title="标题的直接链接">​</a></h3><p>在<code>package.json</code>中, 另外比较重要的配置就是依赖的管理了.</p><p>依赖配置相关的字段主要有下面这些:</p><ul><li><code>dependencies</code>: 指定了项目运行所依赖的模块</li><li><code>devDependencies</code>: 一些只用于开发时的包, 可以用该字段进行管理, 在运行时不会用到的依赖,比如Eslint等等. 将这些依赖保存在次数,可以避免在生产环境被安装.</li><li><code>peerDependencies</code>: 用于指定你正在开发的模块所依赖的模块的版本, 以及用户安装的依赖包版本的兼容性. 在npm3以后就不会强制安装peerDependencies中依赖的版本, 而是抛出一个warn. 不影响继续安装其他的依赖</li><li><code>bundledDependencies</code>: 提供一个包名的数组, 会在发布的时候被一起打包</li><li><code>optionalDependencies</code>: 如果你的依赖是可有可无的,并且又在安装的时候无法获取到,那么就可以把依赖放在这里,npm在安装的时候就不会报错了.</li></ul><p>依赖中的每一项都会按照版本控制的规则进行控制, 我们常见的版本控制的写法有这么几种:</p><ul><li><code>&quot;xxx&quot;: &quot;1.0.0&quot;</code>: 固定版本号</li><li><code>&quot;xxx&quot;: &quot;*&quot;</code>: 任意的版本号</li><li><code>&quot;xxx&quot;: &quot;16.x&quot;</code>: 表示匹配主要的版本号(这里即<code>16.0.0&lt;= version &lt;17.0.0</code>)</li><li><code>&quot;xxx&quot;: &quot;16.3.x&quot;</code>: 表示匹配主要版本和次要版本(这里即<code>16.3.0 &lt;= version &lt;16.4.0</code>)</li><li><code>&quot;xxx&quot;: &quot;~1.0.0&quot;</code>: 保持主版本号和次要版本号不变的情况下, 安装小版本中的最新版本</li><li><code>&quot;xxx&quot;: &quot;^1.0.0&quot;</code>: 保持主版本号不变的情况下, 安装次要版本号和修订版本号为最新的版本</li></ul><p>这里<code>^</code>是<code>npm install</code>的时候采用的默认的安装版本方式.</p><p>另外, 当主版本号是<code>0</code>的时候就会被认为是一个不稳定版本, 版本控制的逻辑有所不同. </p><ul><li>如果主要版本和次要版本都是0, 那么<code>~0.0.z</code>和<code>^0.0.z</code>都会直接被当做固定版本.</li><li>如果主要版本为0, 那么<code>^0.y.z</code>和<code>~0.y.z</code>相同, 只保持<code>z</code>为最新的版本</li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_rm2F" id="依赖锁定">依赖锁定<a class="hash-link" href="#依赖锁定" title="标题的直接链接">​</a></h3><p>在一些场景下, 我们不希望依赖被更新, 所以会在<code>package.json</code>的同级目录下, 生成一个<code>lock</code>文件.</p><p>这个文件的作用是: 在不执行手动更新的情况下, 每次都安装固定的版本, 从而保证每次都使用一致的依赖.</p><p>在使用<code>package-lock</code>的情况下要确保npm的版本在<code>5.6</code>以后以获得比较稳定的版本控制. </p><h3 class="anchor anchorWithHideOnScrollNavbar_rm2F" id="升级依赖">升级依赖<a class="hash-link" href="#升级依赖" title="标题的直接链接">​</a></h3><p>使用<code>npm outdated</code>可以列出所有依赖的最新版本情况的表格, 包名会渲染到不同的颜色:</p><ul><li>黄色: 不符合我们指定的版本范围, 不需要升级</li><li>红色: 符合我们指定的语义化版本范围, 需要升级</li></ul><p>然后指定<code>npm update</code>就会自动升级所有的红色依赖. </p><h2 class="anchor anchorWithHideOnScrollNavbar_rm2F" id="npm的包管理机制">npm的包管理机制<a class="hash-link" href="#npm的包管理机制" title="标题的直接链接">​</a></h2><p>在早期的npm包管理中, npm会简单粗暴的, 把所有依赖以递归的方式, 严格按照<code>package.json</code>中的结构以及子依赖包的<code>package.json</code>结构安装到他们各自的<code>node_module</code>中. 直到子依赖包不再依赖其他的模块. </p><p><img loading="lazy" alt="alt" src="/assets/images/2021-09-21-23-29-51-7a521c7e71a5e45e3ee3b60c97af881f.png" width="1166" height="1046" class="img_wb0S"></p><p>虽然这种管理方式, 对于依赖的层级看起来非常清晰, 但是也会存在依赖冗余的问题. 比如两个子依赖都依赖同一个项目, 那么这个项目会被安装两次, 并且整个项目的嵌套层级非常深.</p><p>为了解决这个问题, npm在3.x对嵌套结构进行了打平, 也就是说, 安装模块的时候, 会把直接依赖和子依赖以及子依赖的依赖都优先安装在<code>node_modules</code>的根目录下面.</p><p><img loading="lazy" src="/assets/images/2021-09-22-11-13-44-900c9e8b9a93fe303c923946bedf7e99.png" width="2084" height="570" class="img_wb0S"></p><p>假如, A依赖包和B依赖包都依赖项目C, 并且依赖了不同的版本, 那么在安装到这个模块的时候:</p><ul><li>npm会判断已经安装的模块是否符合版本范围, 符合则跳过</li><li>不符合则在当前模块的<code>node_modules</code>下安装该模块.</li></ul><p>此时, 我们可能会得到这样的目录结构:</p><p><img loading="lazy" src="/assets/images/2021-09-22-11-24-01-3133f785f9cc35143aabcb930e50b352.png" width="2016" height="1148" class="img_wb0S"></p><p>对应这样的目录结构, 当我们去搜索一个模块的时候, 对应的查找流程就是这样的:</p><ol><li>在当前模块的路径下搜索</li><li>在当前模块的<code>node_modules</code>路径下搜索</li><li>在上级模块的<code>node_modules</code>路径下搜索</li><li>...</li><li>直到在全局路径中的<code>node_modules</code>路径下搜索</li></ol><p>在这种模式下, 我们解决了部分的模块依赖问题, 但是也带来了新的问题.</p><p>在<code>npm install</code>的时候, 是按照<code>package.json</code>中的模块顺序来依次的解析模块和安装依赖的, 也就是说, 模块的排列顺序就决定了最终生成的<code>node_modules</code>的目录结构.</p><p>比如, 当你的A依赖包和B依赖包都依赖C的不同版本, 那么<code>node_modules</code>中, 首层的C依赖的版本, 就取决于A和B在<code>package.json</code>中的先后顺序. </p><p>如果是先B后A:</p><p><img loading="lazy" src="/assets/images/2021-09-22-11-24-01-3133f785f9cc35143aabcb930e50b352.png" width="2016" height="1148" class="img_wb0S"></p><p>如果是先A后B:</p><p><img loading="lazy" src="/assets/images/2021-09-22-11-37-11-8aa3042ba8cb7234d8cc93f57c8ef37f.png" width="2054" height="1074" class="img_wb0S"></p><p>此外, 如果我们只在<code>package.json</code>中锁定大版本, 那么某些依赖包的小版本更新后, 同样会造成依赖结构的变化.</p><p>这种情况下, 我们就必须借助<code>package-lock.json</code>文件, 把所有的依赖版本确定下来, 这样才能固定<code>node_modules</code>的层级结构.</p><h3 class="anchor anchorWithHideOnScrollNavbar_rm2F" id="package-lockjson文件结构"><code>package-lock.json</code>文件结构<a class="hash-link" href="#package-lockjson文件结构" title="标题的直接链接">​</a></h3><p><img loading="lazy" src="/assets/images/2021-09-22-14-12-19-3425767b3a51a4ee84a952d7d2c445be.png" width="2406" height="640" class="img_wb0S"></p><p>注意, 这里并不是所有子依赖都会有<code>dependencies</code>属性的, 只有子依赖和当前已经安装的依赖发生冲突之后, 才会有这个属性. </p><p>这样依赖, lock文件中的层级结构和实际的<code>node_modules</code>文件就是一一对应的, 以保证每次<code>npm install</code>生成的<code>node_modules</code>一样的层级结构. </p><p><code>lock</code>还有一个好处, 因为已经缓存了每个包的具体的版本和下载的链接, 所以就不需要再去远程仓库进行查询, 直接在安装完成后, 进入文件完整性校验即可. </p><h3 class="anchor anchorWithHideOnScrollNavbar_rm2F" id="npm本地缓存">npm本地缓存<a class="hash-link" href="#npm本地缓存" title="标题的直接链接">​</a></h3><p>在使用<code>npm install</code>安装完依赖后, <code>npm</code>会在本地的缓存目录缓存一遍这些包.</p><p>我们可以通过<code>npm config get cache</code>查询到缓存所在的目录.</p><p>一般会在用户目录下<code>.npm/_cacache</code>目录下面, 这个目录下面存在两个目录:</p><ul><li><code>content-v2</code>: 存储<code>tar</code>包的缓存</li><li><code>index-v5</code>: 存储<code>tar</code>包的hash</li></ul><p><code>npm</code>在执行安装的时候, 会根据<code>lock</code>文件中的<code>intergrity</code>, <code>version</code>, <code>name</code>生成一个唯一的<code>key</code>对应到<code>index-v5</code>目录下面的缓存记录, 从而找到<code>tar</code>包的<code>hash</code>, 然后根据<code>hash</code>去缓存中找到对应的<code>tar</code>包直接使用.</p><blockquote><p>在<code>npm v5</code>之前, 是直接通过<code>{cache}/{name}/{version}</code>这样的结构表示的.</p></blockquote><p>常用的用于缓存的<code>npm</code>命令有:</p><ul><li><code>npm cache clean</code>: 清除缓存, 为了保证缓存数据的完整性, 一般会加上<code>--force</code>参数</li><li><code>npm cache verify</code>: 验证缓存数据的有效性和完整性, 清理垃圾数据</li></ul><p>基于缓存, npm提供了离线安装模式:</p><ul><li><code>--perfer-offline</code>: 优先使用缓存, 如果没有则从远程仓库下载</li><li><code>--perfer-online</code>: 优先使用网络数据, 如果网络请求失败, 再使用缓存数据</li><li><code>--offline</code>: 不请求网络, 直接使用缓存数据, 一旦缓存不存在, 就安装失败</li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_rm2F" id="yarn的包管理机制yarn1">yarn的包管理机制(yarn1)<a class="hash-link" href="#yarn的包管理机制yarn1" title="标题的直接链接">​</a></h2><p>yarn出现在2016年, 当时npm还处于v3版本, 也就是简单粗暴的递归模式. 没有扁平化依赖, 没有lock文件. yarn针对原来npm的缺陷提出了自己的解决办法, 并对npm后续的更新造成了深刻的影响.</p><p>yarn的特性大致有这么一些:</p><ul><li>生成<code>yarn.lock</code>: 明确依赖版本和依赖结构, 在任何环境下都能得到一致的依赖结构</li><li>扁平化安装: 将依赖包的不同版本, 按照一定策略归化为一定的版本范围</li><li>使用并发请求: 类似并发连接池</li><li>引入了包缓存机制.</li></ul><p>我们这里讨论的是<code>yarn1</code>的版本管理模式.</p><h3 class="anchor anchorWithHideOnScrollNavbar_rm2F" id="yarnlock版本锁定"><code>yarn.lock</code>版本锁定<a class="hash-link" href="#yarnlock版本锁定" title="标题的直接链接">​</a></h3><p>与<code>npm</code>的<code>package-lock.json</code>不同, <code>yarn.lock</code>使用的是一种自定义的文件格式.</p><p>除此之外, <code>yarn.lock</code>中子依赖的版本号是不固定的, 这就意味着单独的<code>yarn.lock</code>是没有办法确定<code>node_modules</code>的目录结构的, 还需要和<code>package.json</code>文件组合. 而<code>package-lock.json</code>则只需要它自己就可以了.</p><p><code>yarn.lock</code>的文件内容看起来像这样:</p><div class="language-txt codeBlockContainer_x9vG theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_XBdA"><pre tabindex="0" class="prism-code language-txt codeBlock_E3X_ thin-scrollbar"><code class="codeBlockLines_WzRP"><span class="token-line" style="color:#393A34"><span class="token plain"># THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># yarn lockfile v1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&quot;@tootallnate/once@1&quot;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  version &quot;1.1.2&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  resolved &quot;https://registry.yarnpkg.com/@tootallnate/once/-/once-1.1.2.tgz#ccb91445360179a04e7fe6aff78c00ffc1eeaf82&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  integrity sha512-RbzJvlNzmRq5c3O09UipeuXno4tA1FE6ikOjxZK0tuxVv3412l64l5t1W5pj4+rJq9vpkm/kwiR07aZXnsKPxw==</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">address@&gt;=0.0.1, address@^1.0.0:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  version &quot;1.1.2&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  resolved &quot;https://registry.yarnpkg.com/address/-/address-1.1.2.tgz#bf1116c9c758c51b7a933d296b72c221ed9428b6&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  integrity sha512-aT6camzM4xEA54YVJYSqxz1kv4IHnQZRtThJJHhUMRExaU5spC7jX5ugSwTaTgJliIgs4VhZOk7htClvQ/LmRA==</span><br></span></code></pre><div class="buttonGroup_JJJj"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_lfBc" aria-hidden="true"><svg class="copyButtonIcon_fJbv" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_YUzz" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>你可以发现, 在<code>yarn.lock</code>文件中, 每个包的版本是一个逗号拼接的数组, 他表示所有的依赖该包的范围. 每个包下面都有对应的字段, 这些字段的含义和<code>package-lock.json</code>中的定义是类似的:</p><ul><li>version: 符合包的语义化版本的确切的一个版本</li><li>resolved: 记录包的地址, 此外, hash中的值是<code>shasum</code></li><li>dependencies: 记录当前包的依赖</li></ul><p>yarn会把所有包的依赖提升到顶层去. 对于可以合并的同名依赖, 就用逗号分隔, 作为顶层的一个key, 对于不能合并的, 则视为两个独立的顶层Key. </p><p>在具体的<code>node_modules</code>文件中, 则只会出现最新版本的包.</p><p>比如说, 我们现在的项目中依赖同一个包的两个版本:</p><div class="language-txt codeBlockContainer_x9vG theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_XBdA"><pre tabindex="0" class="prism-code language-txt codeBlock_E3X_ thin-scrollbar"><code class="codeBlockLines_WzRP"><span class="token-line" style="color:#393A34"><span class="token plain">fs-extra@^8.1.0:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  version &quot;8.1.0&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  resolved &quot;https://registry.yarnpkg.com/fs-extra/-/fs-extra-8.1.0.tgz#49d43c45a88cd9677668cb7be1b46efdb8d2e1c0&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  integrity sha512-yhlQgA6mnOJUKOsRUFsgJdQCvkKhcz8tlZG5HBQfReYZy46OwLcY+Zia0mtdHsOo9y/hP+CxMN0TU9QxoOtG4g==</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  dependencies:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    graceful-fs &quot;^4.2.0&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    jsonfile &quot;^4.0.0&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    universalify &quot;^0.1.0&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fs-extra@^9.0.1:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  version &quot;9.1.0&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  resolved &quot;https://registry.yarnpkg.com/fs-extra/-/fs-extra-9.1.0.tgz#5954460c764a8da2094ba3554bf839e6b9a7c86d&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  integrity sha512-hcg3ZmepS30/7BSFqRvoo3DOMQu7IjqxO5nCDt+zM9XWjb33Wg7ziNT+Qvqbuc3+gWpzO02JubVyk2G4Zvo1OQ==</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  dependencies:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    at-least-node &quot;^1.0.0&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    graceful-fs &quot;^4.2.0&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    jsonfile &quot;^6.0.1&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    universalify &quot;^2.0.0&quot;</span><br></span></code></pre><div class="buttonGroup_JJJj"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_lfBc" aria-hidden="true"><svg class="copyButtonIcon_fJbv" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_YUzz" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这两个版本不可合并, 所以yarn会把它们两个都放在<code>yarn.lock</code>文件中. </p><p>但是在<code>node_modules</code>文件夹下, 默认会放置<code>fs-extra@9.0.1</code>版本的模块, 而<code>fs-extra@8.1.0</code>这个包会放在对应引用它的依赖的<code>node_modules</code>文件夹中. </p><p>这里和<code>npm</code>的处理逻辑有所不同.</p><h3 class="anchor anchorWithHideOnScrollNavbar_rm2F" id="yarn缓存管理">yarn缓存管理<a class="hash-link" href="#yarn缓存管理" title="标题的直接链接">​</a></h3><p>类似于<code>npm</code>的<code>cache</code>命令, yarn也提供了几个缓存管理命令:</p><ul><li><code>yarn cache ls</code>: 列出当前缓存的包的列表</li><li><code>yarn cache dir</code>: 显示缓存的目录</li><li><code>yarn cache clean</code>: 清理缓存</li></ul><p>一般, <code>yarn</code>的缓存目录默认放在<code>Library/Caches/Yarn/</code>的目录下面, 具体的你可以通过命令调用查看.</p><p>Yarn的缓存管理要显得更加语义化一些:</p><div class="language-txt codeBlockContainer_x9vG theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_XBdA"><pre tabindex="0" class="prism-code language-txt codeBlock_E3X_ thin-scrollbar"><code class="codeBlockLines_WzRP"><span class="token-line" style="color:#393A34"><span class="token plain">- npm-yorkie-2.0.0-92411912d435214e12c51c2ae1093e54b6bb83d9-integrity</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- npm-zeromq-5.2.8-94b0b85e4152e98b8bb163f1db4a34280d44d9d0-integrity</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- npm-zrender-5.1.1-0515f4f8cc0f4742f02a6b8819550a6d13d64c5c-integrity</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- npm-zscroller-0.4.8-69eed68690808eedf81f9714014356b36cdd20f4-integrity</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- npm-zwitch-1.0.5-d11d7381ffed16b742f6af7b3f223d5cd9fe9920-integrity</span><br></span></code></pre><div class="buttonGroup_JJJj"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_lfBc" aria-hidden="true"><svg class="copyButtonIcon_fJbv" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_YUzz" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>它的缓存目录下面都是类似这样的文件夹, 文件的的名称以<code>npm-</code>开头, 以包名, 版本号以及hash值组成. </p><p><code>yarn</code>默认使用的是<code>perfer-online</code>模式, 也就是说, 它会先尝试从远程仓库下载, 如果连接失败则在尝试从缓存中读取. 如果你希望采用离线优先策略, 也提供了<code>--offline</code>参数:</p><div class="language-shell codeBlockContainer_x9vG theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_XBdA"><pre tabindex="0" class="prism-code language-shell codeBlock_E3X_ thin-scrollbar"><code class="codeBlockLines_WzRP"><span class="token-line" style="color:#393A34"><span class="token function" style="color:#d73a49">yarn</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">add</span><span class="token plain"> --offline</span><br></span></code></pre><div class="buttonGroup_JJJj"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_lfBc" aria-hidden="true"><svg class="copyButtonIcon_fJbv" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_YUzz" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>此外, yarn是支持配置离线镜像的:</p><div class="language-shell codeBlockContainer_x9vG theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_XBdA"><pre tabindex="0" class="prism-code language-shell codeBlock_E3X_ thin-scrollbar"><code class="codeBlockLines_WzRP"><span class="token-line" style="color:#393A34"><span class="token function" style="color:#d73a49">yarn</span><span class="token plain"> config </span><span class="token builtin class-name">set</span><span class="token plain"> yarn-offline-mirror ./npm-packages-offline-cache</span><br></span></code></pre><div class="buttonGroup_JJJj"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_lfBc" aria-hidden="true"><svg class="copyButtonIcon_fJbv" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_YUzz" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>离线镜像不同于缓存. 缓存是从注册中心下载的解压缩的tar包, 这些缓存是基于特性的工具实现的, npm有npm的缓存, yarn有yarn的缓存, 并且还有可能在npm的不同版本下机制也是不同的. 而离线镜像中的<code>tar</code>包不会受到工具和工具版本的影响, 并且存储后的文件也有利于存储. 更详细的步骤可以参照<a href="https://classic.yarnpkg.com/blog/2016/11/24/offline-mirror/" target="_blank" rel="noopener noreferrer">官方文档</a></p><p>(实际上, 我们看到在npm的缓存机制下, 缓存包是以tar形式保存的)</p><h2 class="anchor anchorWithHideOnScrollNavbar_rm2F" id="pnpm的包管理机制">pnpm的包管理机制<a class="hash-link" href="#pnpm的包管理机制" title="标题的直接链接">​</a></h2><p><code>npm</code>的v3以后的版本管理和<code>yarn</code>1的版本管理都采用了将依赖打平的方式, 这么做的好处在于减少层级深度和依赖冗余, 但是也带来的新的问题:</p><ol><li>最严重的问题就是幽灵依赖的问题, 模块可以访问它们不依赖的包</li><li>压平依赖的树算法非常的复杂</li><li>一些包必须复制到一个项目的<code>node_modules</code>文件中</li></ol><p>我们回顾之所以要将包进行扁平化的理由:</p><ol><li>在原来的npm的包管理机制下, <code>node_modules</code>会发生很深的嵌套.</li><li>大量的相同依赖冗余在不同的依赖包中.</li></ol><p><code>pnpm</code>实际上是提出了另一种解决这个问题的方法, 即利用<code>硬链接</code>将所有的包集中到全局管理.</p><p>也就是说, <code>node_module</code>文件夹中还是保持了和依赖图谱完全一致的文件目录结构, 但是又能避免依赖冗余和层级过深的问题.</p><p>在<code>linux</code>中, 硬链接就是指通过索引节点来进行链接. 在linux的文件系统中, 保存在磁盘分区中的文件不论是什么类型都会给它分配一个编号, 称为索引节点号. 在Linux中, 多个文件名指向同一个索引节点号是被允许的. 也就是说, linux允许文件拥有多个<strong>有效路径</strong>.</p><p>基于这种机制, <code>pnpm</code>把所有的依赖包都防止在<code>.pnpm</code>文件下面, 在<code>.pnpm</code>中平铺的存储这所有的包, 所以每个包都可以在以这种命名模式的文件夹中被找到:</p><div class="codeBlockContainer_x9vG theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_XBdA"><pre tabindex="0" class="prism-code language-text codeBlock_E3X_ thin-scrollbar"><code class="codeBlockLines_WzRP"><span class="token-line" style="color:#393A34"><span class="token plain">.pnpm/&lt;name&gt;@&lt;version&gt;/node_modules/&lt;name&gt;</span><br></span></code></pre><div class="buttonGroup_JJJj"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_lfBc" aria-hidden="true"><svg class="copyButtonIcon_fJbv" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_YUzz" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>官方称之为: 虚拟存储目录.</p><p>这样的存储结构避免的<code>npm-v3</code>之前的版本中嵌套<code>node_modules</code>引起的长路径的问题, 也与<code>npm-v3</code>之后的版本中的平铺结构不同, 它保留了依赖包之间的真实的拓扑结构.</p><p>这么处理依赖, 带来了几个好处:</p><ol><li>保留了严格对应的node_modules层级关系, <code>node_modules</code>文件夹中只会存在真实依赖的依赖项</li><li>由于模块是全局共享的, 这解决了项目包的大小问题, 并且由于<code>pnpm</code>采用缓存优先的策略, 使得包复用的概率变的很高, 项目依赖的二次安装速度大大提升.</li><li>没有打平依赖带来幽灵依赖的问题</li></ol><h3 class="anchor anchorWithHideOnScrollNavbar_rm2F" id="pnpm中的peerdep依赖问题">pnpm中的peerDep依赖问题<a class="hash-link" href="#pnpm中的peerdep依赖问题" title="标题的直接链接">​</a></h3><p>假设, 我们现在有两个项目<code>package-a</code>和<code>package-b</code>:</p><ul><li><code>package-a</code>依赖<code>lib-a@1.0.0</code>和<code>lib-b@1.0.0</code> </li><li><code>package-b</code>依赖<code>lib-a@1.0.0</code>和<code>lib-b@1.1.0</code></li><li><code>lib-a</code>存在一个<code>peerDeps</code>是<code>lib-b@^1.0.0</code></li></ul><p>如果我们现在在项目中要同时安装<code>package-a</code>以及<code>package-b</code>, 在<code>.pnpm</code>中, 需要把所有依赖铺平:</p><div class="codeBlockContainer_x9vG theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_XBdA"><pre tabindex="0" class="prism-code language-text codeBlock_E3X_ thin-scrollbar"><code class="codeBlockLines_WzRP"><span class="token-line" style="color:#393A34"><span class="token plain">package-a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">package-b</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">lib-a@1.0.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">lib-b@1.0.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">lib-b@1.1.0</span><br></span></code></pre><div class="buttonGroup_JJJj"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_lfBc" aria-hidden="true"><svg class="copyButtonIcon_fJbv" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_YUzz" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>显然, <code>package-a</code>和<code>package-b</code>是分别依赖<code>lib-b</code>的两个版本的, 但是<code>lib-b</code>同时是<code>lib-a</code>的依赖, 那么导入<code>lib-a</code>的时候应该处理哪一个<code>lib-b</code>呢? 显然不能随便选择一个, 因为<code>package-a</code>和<code>package-b</code>都是依赖<code>lib-a</code>的, 随便挑一个另一个就会报错.</p><p>所以这种情况下, <code>lib-a</code>就会在<code>pnpm</code>中<code>.pnpm</code>里面出现两次, 一次链接到<code>lib-b@1.0.0</code>, 一次链接到<code>lib-b@1.1.0</code>.</p><p>也就是说, 我们得到了以下的<code>.pnpm</code>目录:</p><div class="language-txt codeBlockContainer_x9vG theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_XBdA"><pre tabindex="0" class="prism-code language-txt codeBlock_E3X_ thin-scrollbar"><code class="codeBlockLines_WzRP"><span class="token-line" style="color:#393A34"><span class="token plain">package-a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">package-b</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">lib-a@1.0.0+lib-b@1.0.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">lib-a@1.0.0+lib-b@1.1.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">lib-b@1.0.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">lib-b@1.1.0</span><br></span></code></pre><div class="buttonGroup_JJJj"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_lfBc" aria-hidden="true"><svg class="copyButtonIcon_fJbv" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_YUzz" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithHideOnScrollNavbar_rm2F" id="yarn2-pnp模式">yarn2, PnP模式<a class="hash-link" href="#yarn2-pnp模式" title="标题的直接链接">​</a></h2><p>PnP模式比起pnpm的全局硬链接模式更加激进一些, 它直接把<code>node_modules</code>给干掉了. </p><p>在PnP模式下, Yarn会维护一张静态的映射表, 这个表中会包含:</p><ul><li>当前依赖树中包含了哪些依赖包以及对应的版本组</li><li>这些依赖包的依赖关系</li><li>这些依赖包在文件系统中的具体位置</li></ul><p>这个映射表以<code>.pnp.js</code>文件的形式保存在项目的根目录下.</p><p>在项目进行依赖安装的时候, <code>yarn</code>不会把依赖拷贝到<code>node_modules</code>目录, 而是会在<code>.pnp.js</code>中记录下该依赖在缓存中的具体位置. 这样就避免了大量的I/O操作, 同时在项目中也不会生成<code>node_modules</code>目录. </p><p>PnP模式的优点在于:</p><ul><li>完全摆脱了<code>node_modules</code>的限制</li><li>提高了模块的加载效率: 通过<code>.pnp.js</code>文件就能直接定位到具体的模块的地址, 省去了一层层查找模块位置的过程</li><li>不再受同名模块的不同版本不能在同一个目录的限制(npm中对这种情况就会创建出比较复杂的层级结构)</li></ul><p>PnP模式的最大问题就是兼容性问题, 比如目前来说, 前端的很多工具都依赖于<code>node_modules</code>的模块查找机制, 例如:</p><ul><li>Node的require</li><li>Webpack的模块查找</li><li>TypeScript的类型声明文件</li><li>Babel, ESLint的插件的定位机制</li></ul><p>等等</p><h2 class="anchor anchorWithHideOnScrollNavbar_rm2F" id="deno的包管理">Deno的包管理<a class="hash-link" href="#deno的包管理" title="标题的直接链接">​</a></h2><p>Deno不是包管理工具, 可以理解为一个新的JS运行时框架, 目的是为了解决原来<code>node_modules</code>带来的种种问题. </p><p>Deno的依赖引入是直接引入资源的可访问路径, 不论是url或者本地路径, 不做任何的模块化的处理. 类似于这样:</p><div class="language-js codeBlockContainer_x9vG theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_XBdA"><pre tabindex="0" class="prism-code language-js codeBlock_E3X_ thin-scrollbar"><code class="codeBlockLines_WzRP"><span class="token-line" style="color:#393A34"><span class="token keyword module" style="color:#00009f">import</span><span class="token plain"> </span><span class="token imports punctuation" style="color:#393A34">{</span><span class="token imports"> serve </span><span class="token imports punctuation" style="color:#393A34">}</span><span class="token plain"> </span><span class="token keyword module" style="color:#00009f">from</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;https://deno.land/std@0.54.0/http/server.ts&quot;</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> s </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">serve</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"> </span><span class="token literal-property property" style="color:#36acaa">port</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">8000</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token console class-name">console</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">log</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&quot;http://localhost:8000/&quot;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword control-flow" style="color:#00009f">for</span><span class="token plain"> </span><span class="token keyword control-flow" style="color:#00009f">await</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> req </span><span class="token keyword" style="color:#00009f">of</span><span class="token plain"> s</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  req</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">respond</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"> </span><span class="token literal-property property" style="color:#36acaa">body</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;Hello World\n&quot;</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup_JJJj"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_lfBc" aria-hidden="true"><svg class="copyButtonIcon_fJbv" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_YUzz" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>每个包的路径中包含了引入源+包名+版本号+模块, 全都塞进了一个Url中. </p><p>但是这种引入方式在工程量增大的时候, 可预见的会变的非常的复杂和难以管理, 势必要引入一套依赖管理的机制.</p><p>官方推荐的做法是, 在项目本地建立一个<code>dep.ts</code>的文件, 然后通过<code>dep.ts</code>文件去引入各种本地或者远程的项目依赖. </p><p>比如像这样:</p><div class="language-js codeBlockContainer_x9vG theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_XBdA"><pre tabindex="0" class="prism-code language-js codeBlock_E3X_ thin-scrollbar"><code class="codeBlockLines_WzRP"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> * deps.ts</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> * This module re-exports the required methods from the dependant remote Ramda module.</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> */</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword module" style="color:#00009f">export</span><span class="token plain"> </span><span class="token exports punctuation" style="color:#393A34">{</span><span class="token exports"></span><br></span><span class="token-line" style="color:#393A34"><span class="token exports">  add</span><span class="token exports punctuation" style="color:#393A34">,</span><span class="token exports"></span><br></span><span class="token-line" style="color:#393A34"><span class="token exports">  multiply</span><span class="token exports punctuation" style="color:#393A34">,</span><span class="token exports"></span><br></span><span class="token-line" style="color:#393A34"><span class="token exports"></span><span class="token exports punctuation" style="color:#393A34">}</span><span class="token plain"> </span><span class="token keyword module" style="color:#00009f">from</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;https://x.nest.land/ramda@0.27.0/source/index.js&quot;</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup_JJJj"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_lfBc" aria-hidden="true"><svg class="copyButtonIcon_fJbv" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_YUzz" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>然后在项目中这样引用:</p><div class="language-js codeBlockContainer_x9vG theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_XBdA"><pre tabindex="0" class="prism-code language-js codeBlock_E3X_ thin-scrollbar"><code class="codeBlockLines_WzRP"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> * example.ts</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> */</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword module" style="color:#00009f">import</span><span class="token plain"> </span><span class="token imports punctuation" style="color:#393A34">{</span><span class="token imports"> add</span><span class="token imports punctuation" style="color:#393A34">,</span><span class="token imports"> multiply </span><span class="token imports punctuation" style="color:#393A34">}</span><span class="token plain"> </span><span class="token keyword module" style="color:#00009f">from</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;./deps.ts&quot;</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">function</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">totalCost</span><span class="token punctuation" style="color:#393A34">(</span><span class="token parameter literal-property property" style="color:#36acaa">outbound</span><span class="token parameter operator" style="color:#393A34">:</span><span class="token parameter"> number</span><span class="token parameter punctuation" style="color:#393A34">,</span><span class="token parameter"> </span><span class="token parameter literal-property property" style="color:#36acaa">inbound</span><span class="token parameter operator" style="color:#393A34">:</span><span class="token parameter"> number</span><span class="token parameter punctuation" style="color:#393A34">,</span><span class="token parameter"> </span><span class="token parameter literal-property property" style="color:#36acaa">tax</span><span class="token parameter operator" style="color:#393A34">:</span><span class="token parameter"> number</span><span class="token punctuation" style="color:#393A34">)</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> number </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword control-flow" style="color:#00009f">return</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">multiply</span><span class="token punctuation" style="color:#393A34">(</span><span class="token function" style="color:#d73a49">add</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">outbound</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> inbound</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> tax</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token console class-name">console</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">log</span><span class="token punctuation" style="color:#393A34">(</span><span class="token function" style="color:#d73a49">totalCost</span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#36acaa">19</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">31</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1.2</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token console class-name">console</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">log</span><span class="token punctuation" style="color:#393A34">(</span><span class="token function" style="color:#d73a49">totalCost</span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#36acaa">45</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">27</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1.15</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> * Output</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> * 60</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> * 82.8</span><br></span><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"> */</span><br></span></code></pre><div class="buttonGroup_JJJj"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_lfBc" aria-hidden="true"><svg class="copyButtonIcon_fJbv" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_YUzz" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>也就是说, 移除了包管理工具的概念, 直接在代码层面上组织和管理模块依赖. 对于这种为了去中心化而设计的依赖管理模式, 则需要见仁见智了.</p><h2 class="anchor anchorWithHideOnScrollNavbar_rm2F" id="参考链接">参考链接<a class="hash-link" href="#参考链接" title="标题的直接链接">​</a></h2><ul><li><a href="http://www.conardli.top/blog/article/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96-%E5%89%96%E6%9E%90npm%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%EF%BC%88%E5%AE%8C%E6%95%B4%E7%89%88%EF%BC%89.html" target="_blank" rel="noopener noreferrer">剖析npm的包管理机制（完整版）</a></li><li><a href="https://jishuin.proginn.com/p/763bfbd3bcff" target="_blank" rel="noopener noreferrer">为什么现在我更推荐 pnpm 而不是 npm/yarn?</a></li><li><a href="https://www.kochan.io/nodejs/why-should-we-use-pnpm.html" target="_blank" rel="noopener noreferrer">Why should we use pnpm?</a></li><li><a href="https://pnpm.io/blog/2020/05/27/flat-node-modules-is-not-the-only-way" target="_blank" rel="noopener noreferrer">flat-node-modules-is-not-the-only-way</a></li><li><a href="https://pnpm.io/how-peers-are-resolved" target="_blank" rel="noopener noreferrer">How peers are resolved</a></li><li><a href="https://deno.land/manual/examples/manage_dependencies" target="_blank" rel="noopener noreferrer">Managing dependencies | Deno Manual</a></li><li><a href="https://zhuanlan.zhihu.com/p/145101719" target="_blank" rel="noopener noreferrer">关于 Deno 的依赖管理，有点糟糕，却也有药可救</a></li></ul></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="博文分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/关于 vscode 的一些废话"><div class="pagination-nav__sublabel">较新一篇</div><div class="pagination-nav__label">关于 vscode 的一些废话</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/前端项目结构演进"><div class="pagination-nav__sublabel">较旧一篇</div><div class="pagination-nav__label">前端项目结构演进</div></a></nav></main><div class="col col--2"><div class="tableOfContents_a_w_ thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#从packagejson文件说起" class="table-of-contents__link toc-highlight">从<code>package.json</code>文件说起</a><ul><li><a href="#依赖管理" class="table-of-contents__link toc-highlight">依赖管理</a></li><li><a href="#依赖锁定" class="table-of-contents__link toc-highlight">依赖锁定</a></li><li><a href="#升级依赖" class="table-of-contents__link toc-highlight">升级依赖</a></li></ul></li><li><a href="#npm的包管理机制" class="table-of-contents__link toc-highlight">npm的包管理机制</a><ul><li><a href="#package-lockjson文件结构" class="table-of-contents__link toc-highlight"><code>package-lock.json</code>文件结构</a></li><li><a href="#npm本地缓存" class="table-of-contents__link toc-highlight">npm本地缓存</a></li></ul></li><li><a href="#yarn的包管理机制yarn1" class="table-of-contents__link toc-highlight">yarn的包管理机制(yarn1)</a><ul><li><a href="#yarnlock版本锁定" class="table-of-contents__link toc-highlight"><code>yarn.lock</code>版本锁定</a></li><li><a href="#yarn缓存管理" class="table-of-contents__link toc-highlight">yarn缓存管理</a></li></ul></li><li><a href="#pnpm的包管理机制" class="table-of-contents__link toc-highlight">pnpm的包管理机制</a><ul><li><a href="#pnpm中的peerdep依赖问题" class="table-of-contents__link toc-highlight">pnpm中的peerDep依赖问题</a></li></ul></li><li><a href="#yarn2-pnp模式" class="table-of-contents__link toc-highlight">yarn2, PnP模式</a></li><li><a href="#deno的包管理" class="table-of-contents__link toc-highlight">Deno的包管理</a></li><li><a href="#参考链接" class="table-of-contents__link toc-highlight">参考链接</a></li></ul></div></div></div></div></div><footer class="footer"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Wiki doc, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.0fe2848a.js"></script>
<script src="/assets/js/main.755b20c3.js"></script>
</body>
</html>